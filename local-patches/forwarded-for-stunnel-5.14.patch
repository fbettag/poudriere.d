diff --git doc/stunnel.8 doc/stunnel.8
index 691ca5d..a717168 100644
--- doc/stunnel.8
+++ doc/stunnel.8
@@ -922,6 +922,10 @@ This options has been renamed to \fInone\fR.
 .RE
 .RS 4
 .RE
+.IP "\fBxforwardedfor\fR = yes | no" 4
+.IX Item "xforwardedfor = yes | no"
+append an 'X-Forwarded-For:' HTTP request header providing the
+client's IP address to the server.
 .IP "\fBverify\fR = \s-1LEVEL\s0" 4
 .IX Item "verify = LEVEL"
 verify peer certificate
diff --git src/client.c src/client.c
index af195f4..188f7c0 100644
--- src/client.c
+++ src/client.c
@@ -48,6 +48,8 @@
 #define SHUT_RDWR 2
 #endif
 
+#define IPLEN 40
+
 NOEXPORT void client_try(CLI *);
 NOEXPORT void client_run(CLI *);
 NOEXPORT void local_start(CLI *);
@@ -72,6 +74,12 @@ CLI *alloc_client_session(SERVICE_OPTIONS *opt, int rfd, int wfd) {
 
     c=str_alloc_detached(sizeof(CLI));
     c->opt=opt;
+    /* some options need space to add some information */
+    if (c->opt->option.xforwardedfor)
+        c->buffsize = BUFFSIZE - BUFF_RESERVED;
+    else
+        c->buffsize = BUFFSIZE;
+    c->crlf_seen=0;
     c->local_rfd.fd=rfd;
     c->local_wfd.fd=wfd;
     c->redirect=REDIRECT_OFF;
@@ -519,6 +527,28 @@ NOEXPORT void new_chain(CLI *c) {
     s_log(LOG_DEBUG, "Peer certificate was cached (%d bytes)", len);
 }
 
+/** Moves all data from the buffer <buffer> between positions <start> and <stop>
+ * to insert <string> of length <len>. <start> and <stop> are updated to their
+ * new respective values, and the number of characters inserted is returned.
+ * If <len> is too long, nothing is done and -1 is returned.
+ * Note that neither <string> nor <buffer> can be NULL.
+ */
+static int buffer_insert_with_len(char *buffer, int *start, int *stop, int limit, char *string, int len) {
+    if (len > limit - *stop)
+        return -1;
+    if (*start > *stop)
+        return -1;
+    memmove(buffer + *start + len, buffer + *start, *stop - *start);
+    memcpy(buffer + *start, string, len);
+    *start += len;
+    *stop += len;
+    return len;
+}
+
+static int buffer_insert(char *buffer, int *start, int *stop, int limit, char *string) {
+    return buffer_insert_with_len(buffer, start, stop, limit, string, strlen(string));
+}
+
 /****************************** transfer data */
 NOEXPORT void transfer(CLI *c) {
     int watchdog=0; /* a counter to detect an infinite loop */
@@ -543,16 +573,16 @@ NOEXPORT void transfer(CLI *c) {
     do { /* main loop of client data transfer */
         /****************************** initialize *_wants_* */
         read_wants_read|=!(SSL_get_shutdown(c->ssl)&SSL_RECEIVED_SHUTDOWN)
-            && c->ssl_ptr<BUFFSIZE && !read_wants_write;
+            && c->ssl_ptr<c->buffsize && !read_wants_write;
         write_wants_write|=!(SSL_get_shutdown(c->ssl)&SSL_SENT_SHUTDOWN)
-            && c->sock_ptr && !write_wants_read;
 
+            && c->sock_ptr && !write_wants_read;
         /****************************** setup c->fds structure */
         s_poll_init(c->fds); /* initialize the structure */
         /* for plain socket open data strem = open file descriptor */
         /* make sure to add each open socket to receive exceptions! */
         if(sock_open_rd) /* only poll if the read file descriptor is open */
-            s_poll_add(c->fds, c->sock_rfd->fd, c->sock_ptr<BUFFSIZE, 0);
+            s_poll_add(c->fds, c->sock_rfd->fd, c->sock_ptr<c->buffsize, 0);
         if(sock_open_wr) /* only poll if the write file descriptor is open */
             s_poll_add(c->fds, c->sock_wfd->fd, 0, c->ssl_ptr>0);
         /* poll SSL file descriptors unless SSL shutdown was completed */
@@ -666,7 +696,7 @@ NOEXPORT void transfer(CLI *c) {
         /****************************** read from socket */
         if(sock_open_rd && sock_can_rd) {
             num=readsocket(c->sock_rfd->fd,
-                c->sock_buff+c->sock_ptr, BUFFSIZE-c->sock_ptr);
+                c->sock_buff+c->sock_ptr, c->buffsize-c->sock_ptr);
             switch(num) {
             case -1:
                 if(parse_socket_error(c, "readsocket"))
@@ -686,7 +716,7 @@ NOEXPORT void transfer(CLI *c) {
         /****************************** update *_wants_* based on new *_ptr */
         /* this update is also required for SSL_pending() to be used */
         read_wants_read|=!(SSL_get_shutdown(c->ssl)&SSL_RECEIVED_SHUTDOWN)
-            && c->ssl_ptr<BUFFSIZE && !read_wants_write;
+            && c->ssl_ptr<c->buffsize && !read_wants_write;
         write_wants_write|=!(SSL_get_shutdown(c->ssl)&SSL_SENT_SHUTDOWN)
             && c->sock_ptr && !write_wants_read;
 
diff --git src/common.h src/common.h
index d33ffc4..6ab3ba0 100644
--- src/common.h
+++ src/common.h
@@ -51,6 +51,9 @@
 /* I/O buffer size: 18432 (0x4800) is the maximum size of SSL record payload */
 #define BUFFSIZE 18432
 
+/* maximum space reserved for header insertion in BUFFSIZE */
+#define BUFF_RESERVED 1024
+
 /* how many bytes of random input to read from files for PRNG */
 /* OpenSSL likes at least 128 bits, so 64 bytes seems plenty. */
 #define RANDOM_BYTES 64
diff --git src/options.c src/options.c
index 21344f4..25c1826 100644
--- src/options.c
+++ src/options.c
@@ -1468,6 +1468,33 @@ NOEXPORT char *parse_service_option(CMD cmd, SERVICE_OPTIONS *section,
 
 #endif /* !defined(OPENSSL_NO_ENGINE) */
 
+    /* xforwardedfor */
+    switch(cmd) {
+    case CMD_BEGIN:
+        section->option.xforwardedfor=0;
+        break;
+    case CMD_EXEC:
+        if(strcasecmp(opt, "xforwardedfor"))
+            break;
+        if(!strcasecmp(arg, "yes"))
+            section->option.xforwardedfor=1;
+        else if(!strcasecmp(arg, "no"))
+            section->option.xforwardedfor=0;
+        else
+            return "argument should be either 'yes' or 'no'";
+        return NULL; /* OK */
+    case CMD_END:
+        break;
+    case CMD_FREE:
+        break;
+    case CMD_DEFAULT:
+        break;
+    case CMD_HELP:
+        s_log(LOG_NOTICE, "%-15s = yes|no append an HTTP X-Forwarded-For header",
+            "xforwardedfor");
+        break;
+    }
+
     /* exec */
     switch(cmd) {
     case CMD_BEGIN:
diff --git src/prototypes.h src/prototypes.h
index a414417..c7aa38d 100644
--- src/prototypes.h
+++ src/prototypes.h
@@ -267,6 +267,7 @@ typedef struct service_options_struct {
         unsigned accept:1;              /* endpoint: accept */
         unsigned client:1;
         unsigned delayed_lookup:1;
+        unsigned xforwardedfor:1;
 #ifdef USE_LIBWRAP
         unsigned libwrap:1;
 #endif
@@ -390,6 +391,8 @@ typedef struct {
     uint64_t sock_bytes, ssl_bytes; /* bytes written to socket and SSL */
     s_poll_set *fds; /* file descriptors */
     uintptr_t redirect; /* redirect to another destination after failed auth */
+    int buffsize; /* current buffer size, may be lower than BUFFSIZE */
+    int crlf_seen; /* the number of successive CRLF seen */
 } CLI;
 
 /**************************************** prototypes for stunnel.c */
